---
title: "[iOS] 클로저 클로저 클로저 클로저 클로저"
layout: single
categories: TIL
tag: [TIL, iOS, swift]
toc: true
---

# Closuer

## Closure의 캡쳐 방식
* closure 내부에서 사용하는 값이 어떠한 변수에 저장되는 것을 캡쳐라고 한다!! <br>
Closure는 값을 캡쳐할 때 Value/Reference 타입에 관계없이 Reference Capture 한다. <br>
Reference Type인 경우에는 값의 주소값을 저장하는 것이 당연한 방법이지만 Swift에서는 Value Type인 값도 캡쳐할 때는 Reference 방식으로 캡쳐를 한다. 즉, **클로저의 변수가 사용되는 시점의 변수의 값을 평가**한다.

### Capture List
```swift
let closure = { [capture1, capture2] in
 
 }
```
이런식으로 캡쳐할 Value 타입의 변수를 []안에 나열한다. -> Closure를 선언할 당시의 값을 Const Value Type으로 캡쳐한다. <br>
하지만 Const Value Type(상수)이기 떄문에 클로저 내부에서 이 변수의 값을 변경할 수 없다. <br>

## 클로저와 ARC
* ARC = 인스턴스의 Reference Count를 자동으로 계산하여 메모리를 관리하는 방법 

### 클로저의 강한 순환 참조
클로저는 참조 타입으로 Heap 영역에 할당! -> Reference 값을 캡쳐할 때는 기본적으로 "strong" 캡쳐! -> 이때 인스턴스의 Reference Count가 증가! -> 인스턴스는 클로저를 참조하고 클로저는 인스턴스의 변수를 참조하는 강한 순환 참조 발생!

### 클로저의 강한 순환 참조 해결법
* weak & unowned + Capture Lists
클로저가 프로퍼티에 접근할 때 참조하는 부분을 Closure Capture List를 이용해 weak, unowned 캡쳐 하는 방법이 있다.

```swift
class A {
    lazy var b: () -> String? = { [weak self] in
        return self?.a
    }
}

or

class A {
    lazy var b: () -> String = { [unowned self] in
        return self?.a
    }
}
```

여기서 weak의 경우 nil을 할당받을 가능성이 있기에 Optional-Type으로 self에 대한 Optional Binding을 해주어야 하지만, unowned의 경우엔 Non-Optional Type으로 self에 대한 Optional Binding 없이 사용이 가능하다.(Capture List로 동작할때)

## 중첨 함수와 @escaping
@escaping이란 키워드 없이 받는 클로저는 모두 non-escaping 클로저이고 다음과 같은 특징을 갖는다.
* 함수 내부에서 직접 실행하기 위해서만 사용한다.
* 파라미터로 받은 클로저는 변수나 상수에 대입할 수 없다.
* 중첩 함수 내부에서 클로저를 사용할 경우, 중첩함수를 리턴할 수 없다.
* 함수의 실행 흐름을 탈출하지 않아, 함수가 종료되기 전에 무조건 실행 되어야 한다.
= 함수가 외부로 탈출하지 못하게 하기위한 방법들

### non-escaping
기본적으로 클로저는 non-escaping 클로저이다. 그래야만 클로저가 이 함수 내부에서만 사용되고 컴파일러가 메모리 관리를 지저분하게 하지 않아도 되어서 성능이 향상되기 때문이다. <br>
escaping 클로저의 경우, 함수가 종료되더라도 실제 클로저가 사용되지 않을 때까지 메모리를 추적해야하므로 관리가 필요하다.